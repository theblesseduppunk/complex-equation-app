import streamlit as st
import pandas as pd
import io

# Inject custom CSS for metallic chrome style
st.markdown(
    """
    <style>
    /* Background gradient with metallic chrome vibes */
    .stApp {
        background: linear-gradient(135deg, #2f2f2f, #4f4f4f, #2f2f2f);
        color: #eee;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    /* Headers with shiny chrome effect */
    h1, h2, h3 {
        color: #c0c0c0;
        text-shadow:
            0 0 5px #fff,
            0 0 10px #b0b0b0,
            0 0 15px #a0a0a0;
    }
    /* Sliders styling */
    .stSlider > div > div > div > input {
        accent-color: #d4d4d4;
    }
    /* Primary buttons */
    button[kind="primary"] {
        background: linear-gradient(90deg, #a9a9a9, #e0e0e0);
        color: #222;
        font-weight: bold;
        border-radius: 8px;
        box-shadow: 0 0 5px #888 inset;
    }
    /* Secondary buttons */
    button[kind="secondary"] {
        background: linear-gradient(90deg, #6f6f6f, #a9a9a9);
        color: white;
        border-radius: 8px;
    }
    </style>
    """,
    unsafe_allow_html=True,
)

st.markdown("# ‚öôÔ∏è‚ú® The Complex Equation Simulator ‚ú®‚öôÔ∏è")

st.markdown(
    """
    Adjust the parameters below to explore how complexity (C) changes.
    Hover over the (i) icons for explanations.
    """
)

with st.expander("üß† Cognitive Parameters üß†"):
    attention = st.slider("Attention (A)", 0.1, 2.0, 1.0, 0.05, help="Focus level or awareness factor.")
    memory = st.slider("Memory (M)", 0.1, 2.0, 0.7, 0.05, help="Memory capacity or retention strength.")
    sensory = st.slider("Sensory Processing (S)", 1, 20, 10, 1, help="Intensity of sensory input.")

with st.expander("üåå Environmental Parameters üåå"):
    higher_dim = st.slider("Higher-Dimensional Space (D‚Çô)", 1.0, 10.0, 4.0, 0.1, help="Dimensional space complexity.")
    R = st.slider("Reality Magnitude (R)", 50, 200, 100, 1, help="Overall scale of the system.")

with st.expander("‚öôÔ∏è Equation Constants ‚öôÔ∏è"):
    alpha = st.slider("Alpha (Œ±)", 0.5, 3.0, 1.5, 0.05, help="Exponent base for Œ±.")
    beta = st.slider("Beta (Œ≤)", 1.0, 5.0, 2.0, 0.05, help="Exponent base for Œ≤.")
    theta = st.slider("Theta (Œ∏)", 0.5, 3.0, 1.0, 0.05, help="Power to which Œ± and Œ≤ are raised.")
    Q = st.slider("Q", 0.1, 2.0, 1.0, 0.05, help="Quality factor.")
    E = st.slider("E", 0.1, 2.0, 1.0, 0.05, help="Efficiency factor.")

def calculate_complexity(R, alpha, theta, S, Q, A, E, M, Dn, beta):
    numerator = R * (alpha ** theta) * S * Q * (1.2 * A) * E * (1.5 * M)
    denominator = Dn * (beta ** theta)
    C = numerator / denominator
    return C

# Calculate complexity
C = calculate_complexity(R, alpha, theta, sensory, Q, attention, E, memory, higher_dim, beta)

st.markdown(f"### Calculated Complexity (C): {C:.2f}")

# Prepare data for visualization
attention_vals = [0.5, 0.7, 0.9, 1.0, 1.2]
memory_vals = [0.4, 0.6, 0.7, 0.8, 1.0]

complexity_attention = [
    calculate_complexity(R, alpha, theta, sensory, Q, a, E, memory, higher_dim, beta) for a in attention_vals
]
complexity_memory = [
    calculate_complexity(R, alpha, theta, sensory, Q, attention, E, m, higher_dim, beta) for m in memory_vals
]

df = pd.DataFrame({
    "Varying Attention": complexity_attention,
    "Varying Memory": complexity_memory
}, index=attention_vals)

st.line_chart(df)

# CSV download button
csv_buffer = io.StringIO()
df.to_csv(csv_buffer)
csv_data = csv_buffer.getvalue()

st.download_button(
    label="Download Complexity Data as CSV",
    data=csv_data,
    file_name='complexity_data.csv',
    mime='text/csv'
)
